//Body.h
/*Лабораторная работа № 9.4.
Создание иерархии классов на основе абстрактного  базового класса «Геометрический объект» 
Описать абстрактный базовый класс «Геометрический объект»(Body), моделирующий общие свойства и поведение геометрических тел различной формы. Базовый класс содержит закрытые переменные, представляющие:
    • название, отражающее форму геометрического тела  (шар, пирамида, куб и т.п.) – поле перечисляемого типа  shape, описание которого имеет вид:   
enum shape {  shar,  prisma,  parallelepiped,  cub,  piramida,  conus, cylinder };
    • исходные параметры  объектов: r – радиус  шара, основания цилиндра или  конуса; h (или H) – 
    высота  конуса, призмы, прямоугольного параллелепипеда и цилиндра; а – ребро  куба; a, b – ребра  основания прямоугольного параллелепипеда;
    • площадь основания  объекта  s_osn,  площадь боковой поверхности s_bok, площадь полной поверхности объекта s_full,  объем объекта v, вес тела  р;
    • материал, из которого сделан объект  – переменная  перечисляемого типа   material:     enum  material { metal, wood, plastic, cardboard };

В описания классов иерархии включить следующие виртуальные методы:
    • для вычисления площади основания, боковой и полной поверхностей объекта класса; 
    • для моделирования сжатия или растяжения тела (увеличение  радиуса  шара,  уменьшение  стороны  куба).
    • для отображения фигуры на экране. В соответствующей  функции-члене  класса  достаточно  вывести текст вида «Рисую  . . . »,  
    где многоточием указано значение поля с названием формы фигуры.
    • для моделирования перемещения фигуры на плоскости (сдвиг центра шара  или  вершины  куба);
Алгоритм решения задачи реализуется в глобальной функции, одним из формальных параметров которой является указатель на базовый класс. 
Все виртуальные методы вызываются через этот соответствующим образом проинициализированный указатель. 
Выводу результатов должно предшествовать название моделируемого геометрического тела  и название параметра, значение которого выводится. 
Описания классов иерархии разместить  в заголовочном файле,  определения методов базового и производных классов – каждого в отдельном файле. 
Глобальную функцию, реализующую алгоритм решения задачи, и  главную функцию программы  разместить  также в отдельных  файлах.  
Для обработки исключительных ситуаций создать иерархию классов исключений во главе с базовым классом, в котором использовать виртуальный метод ErrMsg(), 
выводящий сообщение об ошибке и замещаемый в производных классах 
(«Генерация и обработка исключений для возможных ошибочных ситуаций в шаблонном классе векторов»).
При программировании используйте формулы:
объем тела   v = k * Sосн * h,  где  Sосн   – площадь основания объекта, h – его высота, k – коэффициент, зависящий от формы объекта: 1/3 для конусов и пирамид,   1 – для призм, кубов, параллелепипедов и цилиндров;
вес тела  p = ρ * v.  Удельный вес вещества ρ определяется по виду материала. 
Класс «Куб» (Cub). Создать массив объектов класса, моделирующий металлические кубики с ребром а. 
Вычислить объем и вес каждого кубика с указанием материала и длины ребра.  Определить материал, из которого сделан самый «тяжелый» кубик.

*/
#pragma once


#include <iostream>
#include <vector>
#include <string>


class Body
{    
  protected:
    enum shape {shar, prisma, parallelepiped, cub, piramida, conus, cylinder};
    enum  material { metal, wood, plastic, cardboard };

    static constexpr uint64_t METAL_DENSITY = 5.5;
    static constexpr uint64_t WOOD_DENSITY = 1.1;
    static constexpr uint64_t PLASTIC_DENSITY = 0.7;
    static constexpr uint64_t CARDBOARD_DENSITY = 2.5;


    shape shape_;
    material material_;

    double length_z_;
    double length_x_;
    double length_y_;

    double square_osn_;
    double square_bok_;
    double square_full_;
    double velocity_;
    double power_;

    Body() = default;
    
    virtual void Err_msg(std::string) = 0;

  public:
  class Body_exception : public std::exception {};
    virtual double Square_osn() = 0;
    virtual double Square_bok() = 0;
    virtual double Velocity() = 0;

    virtual ~Body() = 0;
};

Body::~Body() {}